// Templates - Similar to macros, but evaluated at compile time
// Compiler generates code for you based on the rules you define, acting as a blueprint
#include <iostream>
#include <string>
#define Log(x) std::cout << x << std::endl;

// Template does not exist until it is instantiated (called)
// template<class HAHA> // Can use 'class' instead of 'typename' and any name instead of 'T'
template <typename T>  // 'T' is a placeholder for any type, evaluated at compile time
void Print(T val) {    // Template function to avoid overloading for different types
    std::cout << val << std::endl;
}

// Template class with two parameters: a type 'T' and an integer 'N'
template <typename T, int N>
class Array {
private:
    T m_Array[N];  // Array of size N and type T, determined at compile time
public:
    int GetSize() const { return N; }  // Returns the size of the array (N)
};

int main() {
    // Template function example (avoiding type-based overloading)
    Print(5);          // T is deduced to be 'int'
    Print("Hello");    // T is deduced to be 'const char[]'
    Print(2.5);        // T is deduced to be 'double'
    Print<int>(5);     // Explicitly specifying T as 'int'

    // Template class example (array size determined at compile time)
    Array<int, 10> arr;  // Array of 10 integers
    std::cout << arr.GetSize() << std::endl;  // Outputs: 10

    // When template errors occur, they can be difficult to debug since
    // the error messages may not clearly indicate what code was generated by the compiler.
    // If templates become too complex or fragile, consider using function overloading instead.

    return 0;
}
